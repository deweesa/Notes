**Data Models** are how we represent data, how we represent data can have some implications for how it is used. When designing data models there are typically some tradeoffs on the storage/querying of data.
### Relational Model Versus Document Model
[Relational Model] normalizes data into tables, was originally developed in the 60s and 70s. Closely relates to business style transactions/queries and was the original purpose of early relational models. 
#### Birth of NoSQL
In 2010s there was a big push for [NoSQL] models that used document based data models like [JSON]. NoSQL models can handle more throughput, are better oriented to some queries, and are more expressive/dynamic than relational models. 
#### Object Relational Mismatch
Most applications are written in [Object Oriented Programming], which requires some translation between objects in the application and data stored on the database. If there are disconnects between models in the code and in the database this can be referred to as an **impedance mismatch**. [Object-relational mapping] (ORM) frameworks can reduce the overhead or boilerplate code needed to translate between the application and database layer. Some find that document models like [JSON] reduce the impedance mismatch through better **locality**, where data isn't needed to be shredded/normalized across tables.
### Are Document Databases Repeating History?
There are many examples of competing database models to relational, but so far relational models like SQL are the only ones to have really stood the test of time. Document models excel in one-to-many relations, but have weak join support for many to many.
#### Network Model
Network model is conceptually like a tree. Every record can have multiple parents that point to it, so processing a query would consist of traversing these nodes called an access path, simple queries would be like traversing a linked list, but could balloon to be like traversing a N-dimension graph. Worked well for tape drive limitations though.
#### The relational model
Data is normalized into tables, queries will join/traverse the tables as needed. Can rely on a query optimizer to help create the quickest execution path.
#### Comparison to Document Databases
Document databases are similar to hierarchical in that they can have nested records that model one-to-many relations. Document and relational databases are similar in that they use unique identifiers to key.
### Relational Versus Document Databases Today
Document databases main advantage is that they provide better schema flexibility and data locality. Where relational models provide strong join support for complex queries and many-to-one or many-to-many relations.
#### Which Data Model Leads to Simpler Code?
It really all depends on the purpose of the application, there is no magic bullet data model. If you need join support but use document model can run into issues similar to access paths described for network models. If you have your data shredded against tables but always need to join why not compile thins into documents?
#### Schema Flexibility in Document Model
Schemas are typically explicit to the documents structure in document model, could be considered **schema-on-read**. Where as through the table structure of relational models the schema is explicit and sort of baked in.
#### Data Locality for Queries
In document models there isn't a need to perform many joins if all the data you need is in the document. Can make queries really quick, but complicate writes as you need to traverse the document. In some implementations an entire document might need to be rewritten to disk if the changes are large enough. Whereas in relational changes you're just updating tables.
#### Convergence of Document and Relational Databases
Some relational databases storing [XML] or [JSON] in their tables, allowing the blending of both models. Can provide indexing for the documents. Some document databases also have limited join support. There are examples of both camps borrowing from the other side.
### Query Languages for Data
SQL is a **declarative** query language, you describe what you want from your query and the implementation details are hidden from the user. This allows the query engine to make optimization decisions or implementation changes without making queries obsolete. Imperative query languages on the other hand require the user to tell how the data should be queried. 